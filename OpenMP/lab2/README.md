# Лабораторная работа 2

## Анализ циклов

-  **MPI**

``` cpp
for (int i = 2; i < ISIZE; ++i)
    for (int j = 0; j < JSIZE - 3; ++j)
        a[i][j] = sin(5 * a[i - 2][j + 3])
```

Развернем циклы:

``` cpp
/* (2, 0): */ a[2][0] = sin(5 * a[0][3])
/* (2, 1): */ a[2][1] = sin(5 * a[0][4])
/* (2, 2): */ a[2][0] = sin(5 * a[0][5])

// ... //

/* (3, 0): */ a[3][0] = sin(5 * a[1][3])
/* (3, 1): */ a[3][1] = sin(5 * a[1][4])
/* (3, 2): */ a[3][0] = sin(5 * a[1][5])

// ... // 
```

1. Вектор расстояний: 

$$
\vec{D} = (2,-3)
$$

2. Вектор направлений: 

$$ 
\vec{d} = (`<`, `>`)
$$

3. Значение элементов массива сначала определяются, а потом используются - это потоковая зависимость.

4. Внутренний цикл не содержит зависимостей, может быть распараллелен без ограничений. Однако все исполнители внутреннего цикла, завершившие очередную очередную внешнюю операцию, должны начинать новую синхронно $ \Rightarrow $ требуется барьерная синхронизация по окончании внутреннего цикла. Распараллеливание по невнешму циклу или по двум направлениям **невозможно**. 

- **OpenMP**

``` cpp
for (int i = 0; i < ISIZE - 3; ++i)
    for (int j = 2; j < JSIZE; ++j)
        a[i][j] = sin(5 * a[i + 3][j - 2])
```
Развернем циклы:

``` cpp
/* (0, 2): */ a[0][2] = sin(5 * a[3][0])
/* (0, 3): */ a[0][3] = sin(5 * a[3][1])
/* (0, 4): */ a[0][4] = sin(5 * a[3][2])

// ... //

/* (1, 2): */ a[1][2] = sin(5 * a[4][0])
/* (1, 3): */ a[1][3] = sin(5 * a[4][1])
/* (1, 4): */ a[1][4] = sin(5 * a[4][2])

// ... // 
```

1. Вектор расстояний: 

$$
\vec{D} = (-3, 2) 
$$

2. Вектор направлений: 

$$
\vec{d} = (`>`, `<`) 
$$ 

3. Значение элементов сначала используются, а потом определяются - это антизависимость.

4. Внутренний цикл не содержит зависимостей и может быть распараллелен без ограничений. Распараллеливание по внешнему циклу или по двум направлениям допустимо при предварительном резервировании входных данных. Менять местами вненший и внутренний цикл без изменения вычислений **невозможно**.


